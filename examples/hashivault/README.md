
#  Quick-and-Dirty setup for Hashicorp Vault in docker container

If you already know how to install and manage vault, don't use this;
use your estiblished procedures instead. If you are a vault newbie
and want to get something working quickly on a development machine,
this may help.

Prerequisites: docker, docker-compose, bash

```
    # create the docker container and initialize it,
    # retrieve root keys and unseal the server
    scripts/create-vault-docker.sh

    # create an approle and token that secret-keeper app can use
    scripts/make-app-token.sh

    # Optional: If you use 'vault' cli commands(*),
	# and you see an error about HTTP/HTTPS conflict,
	# set the VAULT_ADDR environment variable:
    # *(for Arch linux, in the `vault-bin` package)
	export VAULT_ADDR=http://127.0.0.1:8200/
	vault status
```

If the scripts worked, you can run the hashivault tests!

```
    source secret.env
    cargo test hashivault
```

After running, there should be a vault container listening on
http://127.0.0.1:8200. 
Three files are generated from these scripts:
- init-SECRETS.log - the output log from initial run of the vault
  container. Contains the unseal keys needed for initializing the vault
  after a restart. If you lose these, the vault will be unrecoverable!!
- secret-root.env - sets VAULT_TOKEN environment variable to the root
  token that authorizes all actions on the vault
- secret.env - sets VAULT_TOKEN to an app-specific token that has more
  limited permissions. This is the one that the demo apps use.

In the event the docker container is restarted (or your dev machine
reboots, you will need to unseal it again to make its api available.
cd to this directory and run `scripts/unseal.sh`

## SECURITY-WARNING

The files generated by this script contain credentials that can be used
to compromise all keys on the vault server. Protect these files!!!
The files with secrets are 
  - `init-SECRETS.log`
  - `secret-root.env`
  - `secret.env`

These scripts makes several shortcuts that are not examples
of good security practice. Some of these shortcuts include

  - tokens granted to the app have an unnecessarily long TTL
  - unseal tokens are in a single file,
    instead of being separated and given to different people.
  - the root token and approle token are in the same folder
  - the server is not running in cluster mode and is a single point of
    failure
  - the server uses http, not https (but does listen on localhost only)

This is not how you should use vault in production,
 

## Additional Resources

- Unsealing and Shamir secrets sharing
  - [Seal concepts] https://www.vaultproject.io/docs/concepts/seal

- Transit secrets engine
  - [API documentation](https://www.vaultproject.io/docs/secrets/transit)
  - [10-minute Tutorial intro](https://learn.hashicorp.com/vault/encryption-as-a-service/eaas-transit)

- Policies
  - [Policies API](https://www.vaultproject.io/docs/concepts/policies)

- AppRole 
  - [API documentation](https://www.vaultproject.io/docs/auth/approle)
  - [10-minute tutorial intro](https://learn.hashicorp.com/vault/identity-access-management/approle)


